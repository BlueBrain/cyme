/*
 * CYME, License
 * 
 * Timothee Ewart - Swiss Federal Institute of technology in Lausanne 
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef CYME_TRAIT_HPP
#define CYME_TRAIT_HPP

#include "memory/detail/simd.h"

namespace numeric{
    /**
        \cond I do not need this part in the doc
        \brief Basic trait to avoid duplication into simd_trait
    */
    template <typename T> // TO DO add a safety on the type float and double only
    struct trait{
        typedef T                  value_type;
        typedef value_type*        pointer;
        typedef const pointer      const_pointer;
        typedef value_type &       reference;
        typedef value_type const & const_reference;
    };

    /**
        \brief This trait class associates basic type (float and double) to corresponding SIMD register (__m128, __m128d - 128-bit),
        to allow a generic vectorial exponential
    */
    template <typename T, memory::simd O, int N>
    struct simd_trait : public trait<T>{};
    /* \endcond I do not need this part in the doc */


    template<class T, memory::simd O>
    struct register_trait; //forward declaration

    /**
        \brief Super vector for the unroll double first, Specialization trait for double with SSE SIMD
    */
    template<class T, memory::simd O, int n>
    struct simd_unroll;

    template<class T, memory::simd O>
    struct simd_unroll<T,O,4>{
         typedef typename register_trait<T,O>::trait_register_type register_simd;
         simd_unroll(){}; //else compiler unhappy
         simd_unroll(register_simd _r0, register_simd _r1, register_simd _r2, register_simd _r3):r0(_r0),r1(_r1),r2(_r2),r3(_r3){}
         register_simd r0;register_simd r1; register_simd r2; register_simd r3;
    };

    template<class T,memory::simd O>
    struct simd_unroll<T,O,2>{
         typedef typename register_trait<T,O>::trait_register_type register_simd;
         simd_unroll(){}; //else compiler unhappy
         simd_unroll(register_simd _r0, register_simd _r1):r0(_r0),r1(_r1){}
         register_simd r0;register_simd r1;
    };

    /**
     \brief definition chimera
     */
    template<class T, memory::simd O, int n>
    struct simd_chimera;

    template<class T,memory::simd O>
    struct simd_chimera<T,O,1>{
        typedef T value_type;
        typedef typename register_trait<value_type,O>::trait_register_type register_simd;
        simd_chimera(){};
        simd_chimera(register_simd _r0, value_type _r1):r0(_r0),r1(_r1){}
        register_simd r0;value_type r1;
    };

    template <>
    struct simd_trait<double, memory::chimera, 1> : trait<double>{
        typedef simd_chimera<double,  memory::chimera, 1> register_type;
    };


    /**
     \brief structure giving the maximum number of the recursion for the Newton-Raphson division algorithm.
     the precision of the Newton-Raphson algo double at every step. As the approximation of the SIMD _mm_rcp_ps
     function is 12 bits on (x86), I need 2 iterations for the float (mantissa 24 bit) and 3/4 iterations for double (mantissa 52 bit).
     _mm_rcp_ps gives the same precision 12 bit for SSE2 and AVX. On Mic the precision is 14 bit (so 3 iterations) and QPX the prevision is
     8 bits (3 iterations float, 4 iterations double)
     */
    template <typename T, memory::simd O>
    struct div_recursion;
}

#ifdef __x86_64__
    #include "core/simd_vector/detail/x86/trait_x86.ipp"
#endif

#ifdef _ARCH_QP
    #include "core/simd_vector/detail/powerpc64/trait_powerpc64.ipp"
#endif

#ifdef __MIC__
    #include "core/simd_vector/detail/mic/trait_mic.ipp"
#endif

#endif

