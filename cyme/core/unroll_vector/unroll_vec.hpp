/*
 * CYME, License
 * 
 * Timothee Ewart - Swiss Federal Institute of technology in Lausanne 
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef CYME_UNROLL_VEC_HPP
#define CYME_UNROLL_VEC_HPP

namespace numeric{

    /**
      \brief Vector computation class. The SIMD register (hardware) is encapsulated. It is generic, it can be SEE, AVX or QPX.
      the type is given by the trait class (simd_trait)
    */
    template<class T,memory::simd O, int N>
    struct vec_unroll{
        typedef typename vec_simd<T,O>::value_type value_type;
        typedef typename vec_simd<T,O>::pointer pointer;
        typedef typename vec_simd<T,O>::const_pointer const_pointer;
        typedef typename vec_simd<T,O>::register_type register_type;
        typedef vec_simd<T,O> storage_type;

        /**
         \brief construtor desired value else 0, note copy constructor generated automaticaly. Only used for constant.
         */
        inline explicit vec_unroll(const value_type a);

        /**
         \brief construtor without nothing load a value cost */
        inline explicit vec_unroll();

        /**
         \brief construtor for exp and log */
        inline explicit vec_unroll(register_type x);

        /**
         \brief construtor from a pointer
         */
        inline vec_unroll(const_pointer a);

        /**
         \brief bracket operator called by the parser (expr_vec)
         */
        inline vec_unroll& operator()();

        /**
         \brief bracket operator called by the parser (expr_vec)
         */
        inline const vec_unroll& operator()() const;

        /**
         \brief operator *= between two vectors
         */
        inline vec_unroll& operator *=(const vec_unroll& rhs);
        
        /**
         \brief operator /= between two vectors
         */
        inline vec_unroll& operator /=(const vec_unroll& rhs);

        /**
        \brief operator += between two vectors
        */
        inline vec_unroll& operator +=(const vec_unroll& rhs);

        /**
         \brief operator -= between two vectors
        */
        inline vec_unroll& operator -=(const vec_unroll& rhs);

        /**
         \brief Save the value into the register into the memory
        */
        inline void store(pointer a) const;

        /**
         \brief negate the value of the register 
        */
        inline vec_unroll& neg();

#ifdef __FMA__
        /**
         \brief FMA operator
         */
        inline void ma(const vec_unroll& lhs, const vec_unroll& rhs);

        /**
         \brief FMS operator
         */
        inline void ms(const vec_unroll& lhs, const vec_unroll& rhs);

        /**
         \brief FMS operator, 2nd case of the operator -
         */
        inline void nma(const vec_unroll& lhs, const vec_unroll& rhs);

        /**
         \brief FMS operator, 2nd case of the operator -
         */
        inline void nms(const vec_unroll& lhs, const vec_unroll& rhs);
#endif
         /**
         \brief hardware Register
         */
         storage_type r0;
         storage_type r1;
         storage_type r2;
         storage_type r3;
    };

} //end namespace

#include "core/unroll_vector/unroll_vec.ipp"
#include "core/unroll_vector/math/unroll_mul.hpp"
#include "core/unroll_vector/math/unroll_add.hpp"
#include "core/unroll_vector/math/unroll_sub.hpp"
#include "core/unroll_vector/math/unroll_div.hpp"
#include "core/unroll_vector/math/unroll_fma.hpp"
#include "core/unroll_vector/math/unroll_fms.hpp"
#include "core/unroll_vector/math/unroll_exp.hpp"
#include "core/unroll_vector/math/unroll_neg.hpp"

#endif

