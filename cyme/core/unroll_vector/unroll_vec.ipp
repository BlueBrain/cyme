/*
 * CYME, License
 * 
 * Timothee Ewart - Swiss Federal Institute of technology in Lausanne 
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef CYME_UNROLL_VEC_IPP
#define CYME_UNROLL_VEC_IPP

namespace numeric{

    template<class T, memory::simd O, int N>
    vec_unroll<T,O,N>::vec_unroll(const typename vec_unroll<T,O,N>::value_type a){
        r0 =  storage_type(a);
        r1 =  storage_type(a);
        r2 =  storage_type(a);
        r3 =  storage_type(a);
        
//        for(int i=0; i<N; ++i)
//            data[i] = storage_type(a);
    }

    template<class T, memory::simd O, int N>
    vec_unroll<T,O,N>::vec_unroll(){
    }

    template<class T, memory::simd O, int N>
    vec_unroll<T,O,N>::vec_unroll(typename vec_unroll<T,O,N>::const_pointer a){
        r0 = storage_type(a+N*0);
        r1 = storage_type(a+N*1);
        r2 = storage_type(a+N*2);
        r2 = storage_type(a+N*3);
//        for(int i=0; i<N; ++i) 
//            data[i] = storage_type(a+N*i);
    }

    template<class T, memory::simd O, int N>
    vec_unroll<T,O,N>::vec_unroll(typename vec_unroll<T,O,N>::register_type x){
        r0 = storage_type(x);
        r1 = storage_type(x);
        r2 = storage_type(x);
        r2 = storage_type(x);
//        for(int i=0; i<N; ++i) 
//            data[i] = storage_type(x);
    }

    template<class T, memory::simd O, int N>
    vec_unroll<T,O,N>& vec_unroll<T,O,N>::operator()(){
        return *this;
    }

    template<class T, memory::simd O, int N>
    const vec_unroll<T,O,N>& vec_unroll<T,O,N>::operator()() const{
        return *this;
    }

    template<class T, memory::simd O, int N>
    vec_unroll<T,O,N>& vec_unroll<T,O,N>::operator *=(const vec_unroll<T,O,N>& rhs){
          r0 *= rhs.r0;
          r1 *= rhs.r1;
          r2 *= rhs.r2;
          r3 *= rhs.r3;

//        for(int i=0; i<N; ++i)
//            this->data[i] *= rhs.data[i];
        return *this;
    }

    template<class T, memory::simd O, int N>
    vec_unroll<T,O,N>& vec_unroll<T,O,N>::operator /=(const vec_unroll<T,O,N>& rhs){
          r0 /= rhs.r0;
          r1 /= rhs.r1;
          r2 /= rhs.r2;
          r3 /= rhs.r3;
//        for(int i=0; i<N; ++i) 
//            this->data[i] /= rhs.data[i];
        return *this;
    }

    template<class T, memory::simd O, int N>
    vec_unroll<T,O,N>& vec_unroll<T,O,N>::operator +=(const vec_unroll<T,O,N>& rhs){
          r0 += rhs.r0;
          r1 += rhs.r1;
          r2 += rhs.r2;
          r3 += rhs.r3;
//        for(int i=0; i<N; ++i) 
//            this->data[i] += rhs.data[i];
        return *this;
    }

    template<class T, memory::simd O, int N>
    vec_unroll<T,O,N>& vec_unroll<T,O,N>::operator -=(const vec_unroll<T,O,N>& rhs){
          r0 -= rhs.r0;
          r1 -= rhs.r1;
          r2 -= rhs.r2;
          r3 -= rhs.r3;
//        for(int i=0; i<N; ++i) 
//            this->data[i] -= rhs.data[i];
        return *this;
    }

    template<class T, memory::simd O, int N>
    void vec_unroll<T,O,N>::store(typename vec_unroll<T,O,N>::pointer a) const{
        r0.store(a+N*0);
        r1.store(a+N*1);
        r2.store(a+N*2);
        r2.store(a+N*3);
//        for(int i=0; i<N; ++i) 
//            this->data[i].store(a+N*i);
    }

    template<class T, memory::simd O, int N>
    vec_unroll<T,O,N>& vec_unroll<T,O,N>::neg(){
        for(int i=0; i<N; ++i) 
            this->data[i].neg();
       return *this;
    } 

#ifdef __FMA__
    template<class T, memory::simd O, int N>
    void vec_unroll<T,O,N>::ma(const vec_unroll<T,O,N>& lhs, const vec_unroll<T,O,N>& rhs){
        for(int i=0; i<N; ++i)
            this->data[i].ma(lhs.data[i],rhs.data[i]);
    }

    template<class T, memory::simd O, int N>
    void vec_unroll<T,O,N>::ms(const vec_unroll& lhs, const vec_unroll& rhs){
        for(int i=0; i<N; ++i)
            this->data[i].ms(lhs.data[i],rhs.data[i]);
    }

    template<class T, memory::simd O, int N>
    void vec_unroll<T,O,N>::nma(const vec_unroll& lhs, const vec_unroll& rhs){
        for(int i=0; i<N; ++i)
            this->data[i].nma(lhs.data[i],rhs.data[i]);
    }

    template<class T, memory::simd O, int N>
    void vec_unroll<T,O,N>::nms(const vec_unroll& lhs, const vec_unroll& rhs){
        for(int i=0; i<N; ++i)
            this->data[i].nms(lhs.data[i],rhs.data[i]);
    }

#endif

} //end namespace

#endif

