/*
 * CYME, License
 *
 * Timothee Ewart - Swiss Federal Institute of technology in Lausanne
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef CYME_EXPR_VEC_HPP
#define CYME_EXPR_VEC_HPP

namespace numeric{
     /* \cond */
    /* 
     *  this works modelizes template expression method to parse a series of basic operations into a three (during compile time). Therefore I limited
     *  the number of local copy to the minimum. Directly inspired (copy/past and modify ^_^) from C++ template the complete guide, chapter XVIII
     */

     /* helper traits class to select how to refer to an ''expression template node'' * - in general: by reference
     * - for scalars: by value
     */
    template<class T, memory::simd O>
    class vec_scalar;

    //primary template, generic
    template<class T, memory::simd O>
    struct vec_traits{
        typedef T const& exp_ref;
    };

    //partial specialization for scalars
    template<class T, memory::simd O>
    struct vec_traits< vec_scalar<T,O>, O>{
        typedef vec_scalar<T,O> exp_ref;
    };
    /* \endcond */
    
    /** 
      \brief this class participate to the tree creation by recursive process, wrap addition e.g (*it)[0] + (*it)[1]
    */
    template<class T, memory::simd O, class OP1, class OP2>
    class vec_add{
        typename vec_traits<OP1,O>::exp_ref op1;
        typename vec_traits<OP2,O>::exp_ref op2;

    public:
        inline vec_add(OP1 const& a, OP2 const& b):op1(a), op2(b){
        }

        inline vec_simd<T,O> operator()() const{
            return op1() + op2();
        }
    };

    /** 
      \brief this class participate to the tree creation by recursive process, wrap subtraction (*it)[0] - (*it)[1]
    */
    template<class T, memory::simd O, class OP1, class OP2>
    class vec_sub{
        typename vec_traits<OP1,O>::exp_ref op1;
        typename vec_traits<OP2,O>::exp_ref op2;

    public:
        inline vec_sub(OP1 const& a, OP2 const& b):op1(a), op2(b){
        }

        inline vec_simd<T,O> operator()() const{
            return op1() - op2();
        }
    };

    /** 
      \brief this class participate to the tree creation by recursive process, wrap subtraction (*it)[0] * (*it)[1]
    */
    template<class T, memory::simd O, class OP1, class OP2>
    class vec_mul{
        typename vec_traits<OP1,O>::exp_ref op1;
        typename vec_traits<OP2,O>::exp_ref op2;
    public:

        inline vec_simd<T,O> operator()() const{ 
            return op1() * op2();
        }

        inline vec_mul(OP1 const& a, OP2 const& b):op1(a), op2(b){
        }

        //fma/s only
        inline const typename vec_traits<OP1,O>::exp_ref& getop1() const{
             return op1;
        }

        //fma/s only
        inline const typename vec_traits<OP2,O>::exp_ref& getop2() const{
             return op2;
        }
    };    
    
    /** 
      \brief this class participate to the tree creation by recursive process, wrap fma (*it)[0]*(*it)[1] + (*it)[2]
      \warning it is experimental
    */
    template<class T, memory::simd O, class OP1, class OP2, class OP3>
    class vec_muladd{
        typename vec_traits<OP1,O>::exp_ref op1; 
        typename vec_traits<OP2,O>::exp_ref op2;
        typename vec_traits<OP3,O>::exp_ref op3;

    public:

        inline vec_simd<T,O> operator()() const{ 
            return muladd(op1(),op2(),op3());
        }

    inline vec_muladd(vec_mul<T,O,OP1,OP2> const& a, OP3 const& b):op1(a.getop1()), op2(a.getop2()), op3(b){}
    };

    /**
     \brief this class participate to the tree creation by recursive process, wrap fma (*it)[0]*(*it)[1] + (*it)[2]*(*it)[3]
     \warning it is experimental
     */
    template<class T, memory::simd O, class OP1, class OP2, class OP3, class OP4>
    class vec_mul_add_mul{
        typename vec_traits<OP1,O>::exp_ref op1; 
        typename vec_traits<OP2,O>::exp_ref op2;
        typename vec_traits<OP3,O>::exp_ref op3;
        typename vec_traits<OP4,O>::exp_ref op4;

    public:

        inline vec_simd<T,O> operator()() const{ 
            return muladd(op1(),op2(),op3()*op4());
        }

    inline vec_mul_add_mul(vec_mul<T,O,OP1,OP2> const& a, vec_mul<T,O,OP3,OP4> const& b):op1(a.getop1()), op2(a.getop2()), op3(b.getop1()), op4(b.getop2()){}
    };

    /**
     \brief this class participate to the tree creation by recursive process, wrap fma (*it)[0]*(*it)[1] + (*it)[2]*(*it)[3]
     \warning it is experimental
     */
    template<class T, memory::simd O, class OP1, class OP2, class OP3, class OP4>
    class vec_mul_sub_mul{
        typename vec_traits<OP1,O>::exp_ref op1;
        typename vec_traits<OP2,O>::exp_ref op2;
        typename vec_traits<OP3,O>::exp_ref op3;
        typename vec_traits<OP4,O>::exp_ref op4;

    public:

        inline vec_simd<T,O> operator()() const{
            return mulsub(op1(),op2(),op3()*op4());
        }

        inline vec_mul_sub_mul(vec_mul<T,O,OP1,OP2> const& a, vec_mul<T,O,OP3,OP4> const& b):op1(a.getop1()), op2(a.getop2()), op3(b.getop1()), op4(b.getop2()){}
    };

    /** 
      \brief this class participate to the tree creation by recursive process, wrap fms (*it)[0]*(*it)[1] - (*it)[2]
      \warning it is experimental
    */
    template<class T, memory::simd O, class OP1, class OP2, class OP3>
    class vec_mulsub{
        typename vec_traits<OP1,O>::exp_ref op1;
        typename vec_traits<OP2,O>::exp_ref op2;
        typename vec_traits<OP3,O>::exp_ref op3;

    public:

        inline vec_simd<T,O> operator()() const{
            return mulsub(op1(),op2(),op3());
        }

        inline vec_mulsub(vec_mul<T,O,OP1,OP2> const& a, OP3 const& b):op1(a.getop1()), op2(a.getop2()), op3(b){}
    };


    /**
     \brief this class participate to the tree creation by recursive process, help to wrap fms (*it)[2] - (*it)[0]*(*it)[1]
     As (*it)[2] - (*it)[0]*(*it)[1], it exists an operator for this at least on X86
     \warning it is experimental
     */
    template<class T, memory::simd O, class OP1, class OP2, class OP3>
    class vec_negate_muladd{
        typename vec_traits<OP1,O>::exp_ref op1;
        typename vec_traits<OP2,O>::exp_ref op2;
        typename vec_traits<OP3,O>::exp_ref op3;

    public:

        inline vec_simd<T,O> operator()() const{
            return negatemuladd(op1(),op2(),op3()); // -a*b+c <=> c - a*b
        }

        inline vec_negate_muladd(vec_mul<T,O,OP1,OP2> const& a, OP3 const& b):op1(a.getop1()), op2(a.getop2()), op3(b){}
    };

    /**
     \brief this class participate to the tree creation by recursive process, help to wrap fms (*it)[2] - (*it)[0]*(*it)[1]
            As (*it)[2] - (*it)[0]*(*it)[1] = -((*it)[0]*(*it)[1]-(*it)[2]), I just applied previous operator (vec_mulsub) and I negate.
            I do not have such problem with the addition as the operator + is commutative, not the case of the operator - 
     \warning it is experimental
     */
    template<class T, memory::simd O, class OP1>
    class vec_negate{
        typename vec_traits<OP1,O>::exp_ref op1;

    public:

        inline vec_simd<T,O> operator()() const{
            return negate(op1());
        }

        inline vec_negate(OP1 const& a):op1(a){}
    };

    /** 
      \brief this class participate to the tree creation by recursive process, wrap division (*it)[0] * (*it)[1]
    */
    template<class T, memory::simd O, class OP1, class OP2>
    class vec_div{
        typename vec_traits<OP1,O>::exp_ref op1; // I made distinction between operands it can be scalar or vector
        typename vec_traits<OP2,O>::exp_ref op2;
    public:

        inline vec_simd<T,O> operator()() const{ 
            return op1() / op2();
        }

        inline vec_div(OP1 const& a, OP2 const& b):op1(a), op2(b){}
    };

    /** 
      \brief this class participate to the tree creation by recursive process, wrap scalar operations it return a vector
    */
    template<class T, memory::simd O>
    class vec_scalar{
    public:
        explicit inline vec_scalar(T const& a):s(a){
        }

        inline vec_simd<T,O> operator()() const{
            return s;
        }

    private:
        vec_simd<T,O> const s; // valuer of the scalar
    };

    /** 
        \brief This class is an "interface" between the iterator and the computation vector class (SIMD register).
        During the compilation, we will create the tree of operations or DAG. I called also this class Parser into
        my comment
    */
    template<class T, memory::simd O, class Rep = vec_simd<T,O> >
    class vec{
    public:
        typedef T value_type;
        typedef value_type* pointer; 
        typedef const pointer const_pointer;
        typedef Rep base_type;
 
        /**
           \brief default constructor nothing special
        */
        inline explicit vec():expr_rep(){
        }

        /**
           \brief constructor rhs of the operator =, I do not care to save the pointer, as I read only the memory on this side
        */
        inline vec(Rep const& rb):data_pointer(NULL),expr_rep(rb){
        }

        /**
           \brief constructor lhs of the operator =, I need to save the pointer to save the data into the memory after the calculation
        */
        inline vec(const_pointer rb):data_pointer(rb),expr_rep(rb){
        }

        /**
           \brief operator =, create the tree and execute if I do something like *it[0] = *it[0]
        */
        inline vec& operator= (vec const& rhs){
            this->expr_rep() = rhs.expr_rep();
            this->rep()().store(data_pointer);
            return *this;
        }

        /**
           \brief operator =, create the tree and execute  in normal condition
        */
        template<class T2, memory::simd O2, class Rep2>
        inline vec& operator= (vec<T2,O2,Rep2 > const& rhs){
            this->rep()() = rhs.rep()(); //evaluate the three compile time, and execute calculation
            this->rep()().store(data_pointer); //store the SIMD register into main memory
            return *this;
        } 

        /**
           \brief operator +=, create the tree and execute  in normal condition
        */
        template<class T2, memory::simd O2, class Rep2>
        inline vec& operator+= (vec<T2,O2,Rep2 > const& rhs){
            this->rep()() += rhs.rep()(); //evaluate the three compile time, and execute calculation
            this->rep()().store(data_pointer); //store the SIMD register into main memory
            return *this;
        }

        /**
           \brief operator -=, create the tree and execute  in normal condition
        */
        template<class T2, memory::simd O2, class Rep2>
        inline vec& operator-= (vec<T2,O2,Rep2 > const& rhs){
            this->rep()() -= rhs.rep()(); //evaluate the three compile time, and execute calculation
            this->rep()().store(data_pointer); //store the SIMD register into main memory
            return *this;
        }

        /**
           \brief operator *=, create the tree and execute  in normal condition
        */
        template<class T2, memory::simd O2, class Rep2>
        inline vec& operator*= (vec<T2,O2,Rep2 > const& rhs){
            this->rep()() *= rhs.rep()(); //evaluate the three compile time, and execute calculation
            this->rep()().store(data_pointer); //store the SIMD register into main memory
            return *this;
        }

        /**
           \brief operator /=, create the tree and execute  in normal condition
        */
        template<class T2, memory::simd O2, class Rep2>
        inline vec& operator/= (vec<T2,O2,Rep2 > const& rhs){
            this->rep()() /= rhs.rep()(); //evaluate the three compile time, and execute calculation
            this->rep()().store(data_pointer); //store the SIMD register into main memory
            return *this;
        }
        /**
           \brief get the vector class, read only
        */
        inline Rep const& rep() const{
            return expr_rep;
        }
        /**
           \brief get the vector class, write only
        */
        inline Rep& rep(){
            return expr_rep;
        }
    private:
        /**
        \brief need pointer for the operator=, to store the data into the memory, unfortunately I can not have an access to the lfs
        */
        const_pointer data_pointer;
        /** 
        \brief this is the vector_simd class
        */
        Rep expr_rep;
    };
}

#include "controller/expression/expr_vec_ops.hpp"
#ifdef __FMA__
#include "controller/expression/expr_vec_fma.hpp"
#endif

#endif
