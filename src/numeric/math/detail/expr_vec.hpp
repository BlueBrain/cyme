/*
 * CoreBluron, License
 *
 * Timothee Ewart - Swiss Federal Institute of technology in Lausanne
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef COREBLURON_EXPR_VEC_HPP
#define COREBLURON_EXPR_VEC_HPP

namespace numeric{

    /*
     *  this works modelizes template expression method to parse a series of basic operations into a three (during compile time). Therefore I limited
     *  the number of local copy to the minimum. Directly inspired (copy/past and modify ^_^) from C++ template the complete guide, chapter XVIII
     */

    /* helper traits class to select how to refer to an ''expression template node'' * - in general: by reference
     * - for scalars: by value
     */
    template<class T, memory::simd O>
    class vec_scalar;

    //primary template, generic
    template<class T, memory::simd O>
    struct vec_traits{
        typedef T const& exp_ref;
    };

    //partial specialization for scalars
    template<class T, memory::simd O>
    struct vec_traits< vec_scalar<T,O>, O>{
        typedef vec_scalar<T,O> exp_ref;
    };

    template<class T, memory::simd O, class OP1, class OP2>
    class vec_add{
        typename vec_traits<OP1,O>::exp_ref op1;
        typename vec_traits<OP2,O>::exp_ref op2;

    public:
        inline vec_add(OP1 const& a, OP2 const& b):op1(a), op2(b){
        }

        inline vec_simd<T,O> operator()() const{
            return op1() + op2();
        }
    };

    template<class T, memory::simd O, class OP1, class OP2>
    class vec_sub{
        typename vec_traits<OP1,O>::exp_ref op1;
        typename vec_traits<OP2,O>::exp_ref op2;

    public:
        inline vec_sub(OP1 const& a, OP2 const& b):op1(a), op2(b){
        }

        inline vec_simd<T,O> operator()() const{
            return op1() - op2();
        }
    };

    template<class T, memory::simd O, class OP1, class OP2>
    class vec_mul{
        typename vec_traits<OP1,O>::exp_ref op1;
        typename vec_traits<OP2,O>::exp_ref op2;
    public:

        inline vec_simd<T,O> operator()() const{ 
            return op1() * op2();
        }

        inline vec_mul(OP1 const& a, OP2 const& b):op1(a), op2(b){
        }

        //fma/s only
        inline const typename vec_traits<OP1,O>::exp_ref& getop1() const{
             return op1;
        }

        //fma/s only
        inline const typename vec_traits<OP2,O>::exp_ref& getop2() const{
             return op2;
        }
    };    
    
    template<class T, memory::simd O, class OP1, class OP2, class OP3>
    class vec_muladd{
        typename vec_traits<OP1,O>::exp_ref op1; 
        typename vec_traits<OP2,O>::exp_ref op2;
        typename vec_traits<OP3,O>::exp_ref op3;

    public:

        inline vec_simd<T,O> operator()() const{ 
            return muladd(op1(),op2(),op3());
        }

    inline vec_muladd(vec_mul<T,O,OP1,OP2> const& a, OP3 const& b):op1(a.getop1()), op2(a.getop2()), op3(b){}

    };

    template<class T, memory::simd O, class OP1, class OP2, class OP3>
    class vec_mulsub{
        typename vec_traits<OP1,O>::exp_ref op1;
        typename vec_traits<OP2,O>::exp_ref op2;
        typename vec_traits<OP3,O>::exp_ref op3;

    public:

        inline vec_simd<T,O> operator()() const{
            return mulsub(op1(),op2(),op3());
        }

        inline vec_mulsub(vec_mul<T,O,OP1,OP2> const& a, OP3 const& b):op1(a.getop1()), op2(a.getop2()), op3(b){}
    };

    template<class T, memory::simd O, class OP1, class OP2>
    class vec_div{
        typename vec_traits<OP1,O>::exp_ref op1; // I made distinction between operands it can be scalar or vector
        typename vec_traits<OP2,O>::exp_ref op2;
    public:

        inline vec_simd<T,O> operator()() const{ 
            return op1() / op2();
        }

        inline vec_div(OP1 const& a, OP2 const& b):op1(a), op2(b){}
    };

    template<class T, memory::simd O>
    class vec_scalar{
    public:
        explicit inline vec_scalar(T const& a):s(a){
        }

        inline vec_simd<T,O> operator()() const{
            return s;
        }

    private:
        vec_simd<T,O> const s; // valuer of the scalar
    };

    template<class T, memory::simd O, class Rep = vec_simd<T,O> >
    class vec{
    public:
        typedef T value_type;
        typedef value_type* pointer; 
        typedef const pointer const_pointer; 

        inline explicit vec():expr_rep(){
        }

        inline vec(Rep const& rb):data_pointer(NULL),expr_rep(rb){
        }

        inline vec(const_pointer rb):data_pointer(rb),expr_rep(rb){
        }

        inline vec& operator= (vec const& rhs){
            this->expr_rep() = rhs.expr_rep();
            this->rep()().store(data_pointer);
            return *this;
        }

        template<class T2, memory::simd O2, class Rep2>
        inline vec& operator= (vec<T2,O2,Rep2 > const& rhs){
            this->rep()() = rhs.rep()(); //evaluate the three compile time, and execute calculation
            this->rep()().store(data_pointer); //store the SIMD register into main memory
            return *this;
        } 

        template<class T2, memory::simd O2, class Rep2>
        inline vec& operator+= (vec<T2,O2,Rep2 > const& rhs){
            this->rep()() += rhs.rep()(); //evaluate the three compile time, and execute calculation
            this->rep()().store(data_pointer); //store the SIMD register into main memory
            return *this;
        }

        template<class T2, memory::simd O2, class Rep2>
        inline vec& operator-= (vec<T2,O2,Rep2 > const& rhs){
            this->rep()() -= rhs.rep()(); //evaluate the three compile time, and execute calculation
            this->rep()().store(data_pointer); //store the SIMD register into main memory
            return *this;
        }

        template<class T2, memory::simd O2, class Rep2>
        inline vec& operator*= (vec<T2,O2,Rep2 > const& rhs){
            this->rep()() *= rhs.rep()(); //evaluate the three compile time, and execute calculation
            this->rep()().store(data_pointer); //store the SIMD register into main memory
            return *this;
        }

        template<class T2, memory::simd O2, class Rep2>
        inline vec& operator/= (vec<T2,O2,Rep2 > const& rhs){
            this->rep()() /= rhs.rep()(); //evaluate the three compile time, and execute calculation
            this->rep()().store(data_pointer); //store the SIMD register into main memory
            return *this;
        }

        inline Rep const& rep() const{
            return expr_rep;
        }

        inline Rep& rep(){
            return expr_rep;
        }

    private:
        const_pointer data_pointer;        
        Rep expr_rep;
    };
}

#include "numeric/math/detail/expr_vec_algo.hpp"

#endif
