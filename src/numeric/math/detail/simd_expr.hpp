/*
 * CoreBluron, License
 *
 * Timothee Ewart - Swiss Federal Institute of technology in Lausanne
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef COREBLURON_SIMD_EXPR_HPP
#define COREBLURON_SIMD_EXPR_HPP

namespace numeric{

/* 
 *  this works modelizes template expression method to parse a series of basic operations into a three (during compile time). Therefore I limited
 *  the number of local copy to the minimum. Directly inspired (copy/past ^_^) from C++ template the complete guide, chapter XVIII, Have no fear O_6 !
 */

    /* helper traits class to select how to refer to an ''expression template node'' * - in general: by reference
     * - for scalars: by value
     */


    template<class T, memory::simd O>
    class vec_scalar;

    //primary template, generic
    template<class T, memory::simd O>
    struct vec_traits{
        typedef T const& exp_ref;
    };

    //partial specialization for scalars
    template<class T, memory::simd O>
    struct vec_traits< vec_scalar<T,O>, O>{
        typedef vec_scalar<T,O> exp_ref;
    };

    template<class T, memory::simd O, class OP1, class OP2>
    class vec_add{
        typename vec_traits<OP1,O>::exp_ref op1; // I made distinction between operands it can be scalar or vector
        typename vec_traits<OP2,O>::exp_ref op2;

    public:
        inline vec_add(OP1 const& a, OP2 const& b):op1(a), op2(b){
        }

        inline vec<T,O> operator()() const{ // <------------------------------ WELL DO NOT RESPECT THE PATTERN, MAYBE PB 
            return op1() + op2();
        }
    };

    template<class T, memory::simd O, class OP1, class OP2>
    class vec_mul{
        typename vec_traits<OP1,O>::exp_ref op1; // I made distinction between operands it can be scalar or vector
        typename vec_traits<OP2,O>::exp_ref op2;
    public:

        inline vec<T,O> operator()() const{ // <------------------------------ WELL DO NOT RESPECT THE PATTERN, MAYBE PB
            return op1() * op2();
        }

        inline vec_mul(OP1 const& a, OP2 const& b):op1(a), op2(b){
        }
    };

    template<class T, memory::simd O>
    class vec_scalar{
    public:
        explicit inline vec_scalar(T const& a):s(a){
        }

        inline vec<T,O> operator()() const{ // <------------------------------ WELL DO NOT RESPECT THE PATTERN, MAYBE PB
            return vec<T,O>(s);
        }

    private:
        T const& s; // valuer of the scalar
    };

    template<class T, memory::simd O, class Rep = vec<T,O> >
    class Vec{ // TO DO UNIFY NAME<------------------ TO DO 
    public:
        typedef T value_type;
        typedef value_type* pointer; 
        typedef const pointer const_pointer; 

        inline explicit Vec():expr_rep(){
        }

        inline Vec (Rep const& rb):data_pointer(NULL),expr_rep(rb){
        }

        inline Vec (const_pointer rb):data_pointer(rb),expr_rep(rb){
        }

        inline Vec& operator= (Vec const& rhs){
            this->expr_rep() = rhs.expr_rep();
            return *this;
        }

        template<class T2, memory::simd O2, class Rep2>
        inline Vec& operator= (Vec<T2,O2,Rep2 > const& rhs){
            this->rep()() = rhs.rep()(); //evaluate the three
            this->rep()().store(data_pointer); //store the SIMD register into main memory
            return *this;
        } 

        inline Rep const& rep() const{
            return expr_rep;
        }

        inline Rep& rep(){
            return expr_rep;
        }

    private:
        const_pointer data_pointer;        
        Rep expr_rep;
    };

    //addition of two vectors v+w
    template<class T, memory::simd O, class R1, class R2>
    Vec<T,O, vec_add<T,O,R1,R2> >
    inline operator +(Vec<T,O,R1> const& a, Vec<T,O,R2> const& b){
        return Vec<T,O, vec_add<T,O,R1,R2> >(vec_add<T,O,R1,R2>(a.rep(),b.rep()));
    }

    //multiplication of two vectors v*w
    template<class T, memory::simd O, class R1, class R2>
    Vec<T,O, vec_mul<T,O,R1,R2> >
    inline operator *(Vec<T,O,R1> const& a, Vec<T,O,R2> const& b){
        return Vec<T,O,vec_mul<T,O,R1,R2> >(vec_mul<T,O,R1,R2>(a.rep(),b.rep()));
    }

    //multiplication of scalar/vector, lambda*v
    template<class T, memory::simd O, class R2>
    inline Vec<T,O, vec_mul<T,O,vec_scalar<T,O>,R2> >
    operator *(T const& s, Vec<T,O,R2> const& b){
        return Vec<T,O,vec_mul<T,O,vec_scalar<T,O>, R2> >(vec_mul<T,O,vec_scalar<T,O>,R2>(vec_scalar<T,O>(s),b.rep()));
    }



}

#endif
